<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>真牛英雄 | http2.0</title>
    <meta name="description" content="看啥看">
    
    
    <link rel="preload" href="/assets/css/37.styles.c10b3e63.css" as="style"><link rel="preload" href="/assets/js/app.de304580.js" as="script"><link rel="preload" href="/assets/js/24.32698286.js" as="script"><link rel="prefetch" href="/assets/js/10.dd587740.js"><link rel="prefetch" href="/assets/js/0.edfd7b42.js"><link rel="prefetch" href="/assets/js/1.db13ac2e.js"><link rel="prefetch" href="/assets/js/2.6e3d5767.js"><link rel="prefetch" href="/assets/js/3.f72df505.js"><link rel="prefetch" href="/assets/js/4.15e4d33f.js"><link rel="prefetch" href="/assets/js/5.37f2fcbd.js"><link rel="prefetch" href="/assets/js/6.12cc404e.js"><link rel="prefetch" href="/assets/js/7.8b85edfd.js"><link rel="prefetch" href="/assets/js/8.1a03e92f.js"><link rel="prefetch" href="/assets/js/9.17071777.js"><link rel="prefetch" href="/assets/js/11.9916a06e.js"><link rel="prefetch" href="/assets/js/12.5d48726c.js"><link rel="prefetch" href="/assets/js/13.dcb82be7.js"><link rel="prefetch" href="/assets/js/14.05016b97.js"><link rel="prefetch" href="/assets/js/15.e884cf02.js"><link rel="prefetch" href="/assets/js/16.d31c56e0.js"><link rel="prefetch" href="/assets/js/17.b318e07d.js"><link rel="prefetch" href="/assets/js/18.0a374358.js"><link rel="prefetch" href="/assets/js/19.9313a7a0.js"><link rel="prefetch" href="/assets/js/20.56cb6d1d.js"><link rel="prefetch" href="/assets/js/21.737ec51a.js"><link rel="prefetch" href="/assets/js/22.10e8d627.js"><link rel="prefetch" href="/assets/js/23.ea8ab115.js"><link rel="prefetch" href="/assets/js/25.c6220d17.js"><link rel="prefetch" href="/assets/js/26.b0e2c191.js"><link rel="prefetch" href="/assets/js/27.ad9db46a.js"><link rel="prefetch" href="/assets/js/28.42479c2e.js"><link rel="prefetch" href="/assets/js/29.d0556fa8.js"><link rel="prefetch" href="/assets/js/30.0df72cc2.js"><link rel="prefetch" href="/assets/js/31.1fc0335a.js"><link rel="prefetch" href="/assets/js/32.622253fe.js"><link rel="prefetch" href="/assets/js/33.076f6c20.js"><link rel="prefetch" href="/assets/js/34.84540417.js"><link rel="prefetch" href="/assets/js/35.93ad9081.js"><link rel="prefetch" href="/assets/js/36.c6df11bd.js">
    <link rel="stylesheet" href="/assets/css/37.styles.c10b3e63.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      真牛英雄
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blogs/coding/other/linux.html" class="nav-link">代码</a></div><div class="nav-item"><a href="/blogs/bodybuilding/tmf.html" class="nav-link">健身</a></div><div class="nav-item"><a href="/blogs/gameing/" class="nav-link">游戏</a></div><!----></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blogs/coding/other/linux.html" class="nav-link">代码</a></div><div class="nav-item"><a href="/blogs/bodybuilding/tmf.html" class="nav-link">健身</a></div><div class="nav-item"><a href="/blogs/gameing/" class="nav-link">游戏</a></div><!----></nav><ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>区块链</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>其他</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>Http</span><span class="arrow down"></span></p><ul class="sidebar-group-items"><li><a href="/blogs/coding/http/https.html" class="sidebar-link">https</a></li><li><a href="/blogs/coding/http/http2.0.html" class="active sidebar-link">http2.0</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blogs/coding/http/http2.0.html#什么是http2-0" class="sidebar-link">什么是http2.0</a></li><li class="sidebar-sub-header"><a href="/blogs/coding/http/http2.0.html#二进制分帧层" class="sidebar-link">二进制分帧层</a></li><li class="sidebar-sub-header"><a href="/blogs/coding/http/http2.0.html#多路复用共享链接" class="sidebar-link">多路复用共享链接</a></li><li class="sidebar-sub-header"><a href="/blogs/coding/http/http2.0.html#请求优先级" class="sidebar-link">请求优先级</a></li><li class="sidebar-sub-header"><a href="/blogs/coding/http/http2.0.html#服务器推送" class="sidebar-link">服务器推送</a></li><li class="sidebar-sub-header"><a href="/blogs/coding/http/http2.0.html#首部压缩" class="sidebar-link">首部压缩</a></li><li class="sidebar-sub-header"><a href="/blogs/coding/http/http2.0.html#基于完整http-2的通信过程" class="sidebar-link">基于完整http/2的通信过程</a></li><li class="sidebar-sub-header"><a href="/blogs/coding/http/http2.0.html#http-2性能瓶颈" class="sidebar-link">HTTP/2性能瓶颈</a></li></ul></li><li><a href="/blogs/coding/http/handshake.html" class="sidebar-link">http的三次握手</a></li><li><a href="/blogs/coding/http/optimize.html" class="sidebar-link">http请求的tcp瓶颈</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>JavaScript学习</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>NodeJs学习</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>CSS学习</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Vue源码学习</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>React学习</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>docker学习</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Java学习</span><span class="arrow right"></span></p><!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>Spring学习</span><span class="arrow right"></span></p><!----></div></li></ul></div><div class="page"><div class="content"><h1 id="http2-0"><a href="#http2-0" aria-hidden="true" class="header-anchor">#</a> http2.0</h1><p></p><div class="table-of-contents"><ul><li><a href="#什么是http2-0">什么是http2.0</a></li><li><a href="#二进制分帧层">二进制分帧层</a><ul><li><a href="#帧">帧</a></li><li><a href="#消息">消息</a></li><li><a href="#流">流</a></li></ul></li><li><a href="#多路复用共享链接">多路复用共享链接</a></li><li><a href="#请求优先级">请求优先级</a></li><li><a href="#服务器推送">服务器推送</a></li><li><a href="#首部压缩">首部压缩</a></li><li><a href="#基于完整http-2的通信过程">基于完整http/2的通信过程</a><ul><li><a href="#基于alpn的协商过程">基于ALPN的协商过程</a></li><li><a href="#基于http的协商过程">基于HTTP的协商过程</a></li><li><a href="#完整通信过程">完整通信过程</a></li></ul></li><li><a href="#http-2性能瓶颈">HTTP/2性能瓶颈</a></li></ul></div><p></p><h2 id="什么是http2-0"><a href="#什么是http2-0" aria-hidden="true" class="header-anchor">#</a> 什么是http2.0</h2><p>HTTP 2.0是在SPDY（An experimental protocol for a faster web, The Chromium Projects）基础上形成的下一代互联网通信协议。HTTP/2 的目的是通过支持请求与响应的多路复用来较少延迟，通过压缩HTTPS首部字段将协议开销降低，同时增加请求优先级和服务器端推送的支持。</p><h2 id="二进制分帧层"><a href="#二进制分帧层" aria-hidden="true" class="header-anchor">#</a> 二进制分帧层</h2><p>二进制分帧层是http/2的性能增强的核心</p><p>http 1.x在应用层以纯文本的形式进行通信,而http 2.0将所有的传输信息分割为更小的消息和帧,并对他们采用二进制格式编码.
这样,客户端与服务端都需要引入新的二进制编码和解码的机制.
如下图
<img src="/assets/img/http2-frame.58088cad.png" alt="二进制分帧层"></p><h3 id="帧"><a href="#帧" aria-hidden="true" class="header-anchor">#</a> 帧</h3><p>在http1.x时代我们习惯与head和body打交道,到了2.0时代,取而代之的是帧(frame),
它将成为协议中的最小通信单位(未改变http的语义),所有的head和body都会打包到帧内发送</p><p>帧又分为</p><ul><li>header frame(头部帧)</li><li>data frame(数据帧)</li></ul><p>帧的开头9个byte(72bit),后续为payload</p><p>结构见</p><pre class="language-bash"><code> +-----------------------------------------------+
 <span class="token operator">|</span>                 Length <span class="token punctuation">(</span>24<span class="token punctuation">)</span>                   <span class="token operator">|</span>
 +---------------+---------------+---------------+
 <span class="token operator">|</span>   Type <span class="token punctuation">(</span>8<span class="token punctuation">)</span>    <span class="token operator">|</span>   Flags <span class="token punctuation">(</span>8<span class="token punctuation">)</span>   <span class="token operator">|</span>
 +-+-------------+---------------+-------------------------------+
 <span class="token operator">|</span>R<span class="token operator">|</span>                 Stream Identifier <span class="token punctuation">(</span>31<span class="token punctuation">)</span>                      <span class="token operator">|</span>
 +<span class="token operator">=</span>+<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>+
 <span class="token operator">|</span>                   Frame Payload <span class="token punctuation">(</span>0<span class="token punctuation">..</span>.<span class="token punctuation">)</span>                      <span class="token punctuation">..</span>.
 +---------------------------------------------------------------+
</code></pre><p>frame定义如下</p><ul><li><strong>Length</strong> :帧主体长度。24 bits unsigned int
<ul><li>无符号的自然数，24个比特表示，仅表示帧负载（Frame Payload）所占用字节数，不包括帧头所占用的9个字节。默认大小区间为为0~16,384(2^14)，一旦超过默认最大值2^14(16384)，发送方将不再允许发送，除非接收到接收方定义的SETTINGS_MAX_FRAME_SIZE（一般此值区间为2^14 ~ 2^24）值的通知。</li></ul></li><li><strong>Type</strong> ： 类型(8 bits)。
<ul><li>8个比特表示，定义了帧负载的具体格式和帧的语义，HTTP/2规范定义了10个帧类型，这里不包括实验类型帧和扩展类型帧</li><li>DATA            0x0   用于传输HTTP消息体</li><li>HEADERS         0x1   用于传输首部字段</li><li>PRIORITY        0x2   用于指定或重新指定引用资源的优先级。</li><li>RST_STREAM      0x3   用于通知流的非正常终止。</li><li>SETTINGS        0x4   用于约定客户端和服务端的配置数据。比如设置初识的双向流量控制窗口大小</li><li>PUSH_PROMISE    0x5   服务端推送许可。</li><li>PING            0x6   用于计算往返时间，执行“ 活性” 检活。</li><li>GOAWAY          0x7   用于通知对端停止在当前连接中创建流。</li><li>WINDOW_UPDATE   0x8   用于调整个别流或个别连接的流量</li><li>CONTINUATION    0x9</li></ul></li><li><strong>Flags</strong> ： 特定的Type，有一组特定的flag，以便对type做更多约定</li><li><strong>R</strong> : 保留(1bit)。语义未设置并且必须在发送的时候设置为 0</li><li><strong>Stream Identifier</strong> : 流标识符(31 bytes）。
<ul><li>HTTP2场景下，TCP Connection不再只有一对请求+响应了——可以有多个响应。这些响应打包到多个Frame，在一个 Connection 上混合交错的发。接收方必须知道每个Frame属于那个Response，这就是流所标示的了。</li></ul></li></ul><h3 id="消息"><a href="#消息" aria-hidden="true" class="header-anchor">#</a> 消息</h3><p>消息是指逻辑上的HTTP消息（请求/响应）。一系列数据帧组成了一个完整的消息。比如一系列DATA帧和一个HEADERS帧组成了请求消息。</p><h3 id="流"><a href="#流" aria-hidden="true" class="header-anchor">#</a> 流</h3><p>流是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务器端发起的流具有偶数ID。
所有HTTP 2. 0 通信都在一个TCP连接上完成， 这个连接可以承载任意数量的双向数据流Stream。 相应地， 每个数据流以 消息的形式发送， 而消息由一 或多个帧组成，<strong>这些帧可以乱序发送， 然后根据每个帧首部的流标识符重新组装。</strong></p><p>二进制分帧层保留了HTTP的语义不受影响，包括首部、方法等，在应用层来看，和HTTP 1.x没有差别。同时，所有同主机的通信能够在一个TCP连接上完成。</p><h2 id="多路复用共享链接"><a href="#多路复用共享链接" aria-hidden="true" class="header-anchor">#</a> 多路复用共享链接</h2><p>基于二进制分帧层,http2.0可以在共享tcp的基础上,同时发起请求和响应.
http消息被分解成独立的帧,
而不破坏本身的语义,交错的发送,<strong>最后在另一端根据流标识(Stream Identifier)和首部将他们重新组合起来</strong></p><p>对比于http1.x,2.0的性能的提升显而易见,
有效的解决了1.x的队首阻塞问题.(除了tcp层的阻塞仍然无法解决)
同时也不需要通过pipeline机制建立多条TCP连接来实现并行请求与响应</p><p>减少了TCP连接数,对服务器的性能也有了很大的提升</p><h2 id="请求优先级"><a href="#请求优先级" aria-hidden="true" class="header-anchor">#</a> 请求优先级</h2><p>用帧类型为 PRIORITY 来标记优先级
????</p><h2 id="服务器推送"><a href="#服务器推送" aria-hidden="true" class="header-anchor">#</a> 服务器推送</h2><p>HTTP 2.0增加了服务端推送功能，服务端可以根据客户端的请求，提前返回多个响应，推送额外的资源给客户端。</p><p>帧类型为PUSH_PROMISE的帧是服务端向客户端准备推送资源的信号</p><ul><li>如果客户端不需要服务器端PUSH,可以在SETTINGS帧中设定服务端流的值为0,禁用次功能</li><li>PUSH_PROMISE帧中只包含预推送资源的首部。如果客户端对PUSH_PROMISE帧没有意见，服务端在PUSH_PROMISE帧后发送响应的DATA帧开始推送资源。如果客户端已经缓存该资源，不需要再推送，可以选择拒绝PUSH_PROMISE帧</li><li>PUSH_PROMISE必须遵循请求-响应原则，只能借着对请求的响应推送资源。
<ul><li>apache的mod_http2能够开启h2push on服务端Push</li><li>nginx在1.13.9版本加入了服务端push功能<a href="https://www.hi-linux.com/posts/9911.html" target="_blank" rel="noopener noreferrer">Nginx实现http2服务器端推送</a></li></ul></li></ul><h2 id="首部压缩"><a href="#首部压缩" aria-hidden="true" class="header-anchor">#</a> 首部压缩</h2><p>HTTP1.X每一次通信都会携带首部信息用于描述资源属性.
HTTP2.0在客户端和服务端之间使用&quot;首部表&quot;来跟踪和存储之前发送的键值对.
首部表在链接过程中始终存在,新增的键值对会更新到表尾,因此不需要每次通信都携带首部</p><p>同时,HTTP2.0使用了首部压缩技术(HPACK算法)不同于body的GZIP等算法,两者不冲突</p><h2 id="基于完整http-2的通信过程"><a href="#基于完整http-2的通信过程" aria-hidden="true" class="header-anchor">#</a> 基于完整http/2的通信过程</h2><p>对于服务器端是否支持HTTP2.0,是否支持二进制分帧的解码与编码.
两端在进行HTTP2.0通信之前,存在一个<code>协议协商</code>的过程</p><h3 id="基于alpn的协商过程"><a href="#基于alpn的协商过程" aria-hidden="true" class="header-anchor">#</a> 基于ALPN的协商过程</h3><p>ALPN(Application Layer Protocol Negotiation)应用层协议协商</p><p>支持HTTP2.0的浏览器可以在TLS会话层自发完成和服务端的协议协商以确定是否可以使用HTTP2.0通信.</p><p>服务端使用ALPN 监听443端口,默认HTTP1.1允许协商其他协议,比如SPDY和HTTP2.0</p><h3 id="基于http的协商过程"><a href="#基于http的协商过程" aria-hidden="true" class="header-anchor">#</a> 基于HTTP的协商过程</h3><p>通过HTTP Upgrade机制(OKHTTP,NGHTTP2等组件可以实现)通过协商确定适当的协议</p><h3 id="完整通信过程"><a href="#完整通信过程" aria-hidden="true" class="header-anchor">#</a> 完整通信过程</h3><p>在chrome中<code>chrome://net-internals/#http2</code>命令也能捕获HTTP 2.0通信过程</p><h2 id="http-2性能瓶颈"><a href="#http-2性能瓶颈" aria-hidden="true" class="header-anchor">#</a> HTTP/2性能瓶颈</h2><p>????</p></div><!----><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/blogs/coding/http/https.html" class="prev">
          https
        </a></span><span class="next"><a href="/blogs/coding/http/handshake.html">
          http的三次握手
        </a> →
      </span></p></div></div></div></div>
    <script src="/assets/js/24.32698286.js" defer></script><script src="/assets/js/app.de304580.js" defer></script>
  </body>
</html>
